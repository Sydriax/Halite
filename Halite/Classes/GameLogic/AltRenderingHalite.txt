Halite.h   -------------

GLuint vertex_buffer, color_buffer, strength_buffer, vertex_attributes, vertex_shader, geometry_shader, fragment_shader, shader_program;

Halite.cpp -------------

void Halite::render(short& turnNumber)
{
    confirmWithinGame(turnNumber);

	if(!full_game.empty())
	{
		hlt::Map * m = full_game[turnNumber];

		std::vector<float> colors(unsigned int(m->map_width) * m->map_height * 3);
		std::vector<unsigned int> strengths(unsigned int(m->map_width) * m->map_height);

		unsigned int loc = 0;
		unsigned int colorLoc = 0;
		for(auto a = m->contents.begin(); a != m->contents.end(); a++)
		{
			for(auto b = a->begin(); b != a->end(); b++)
			{
				hlt::Color c = color_codes[b->owner];
				colors[colorLoc] = c.r;
				colors[colorLoc + 1] = c.g;
				colors[colorLoc + 2] = c.b;
				strengths[loc] = b->strength;
				colorLoc += 3;
				loc++;
			}
		}

		glBindBuffer(GL_ARRAY_BUFFER, color_buffer);
		glBufferSubData(GL_ARRAY_BUFFER, 0, colors.size() * sizeof(float), colors.data());
		
		glBindBuffer(GL_ARRAY_BUFFER, strength_buffer);
		glBufferSubData(GL_ARRAY_BUFFER, 0, strengths.size() * sizeof(unsigned int), strengths.data());

		glUseProgram(shader_program);
		glBindVertexArray(vertex_attributes);
		glDrawArrays(GL_POINTS, 0, unsigned int(m->map_width) * m->map_height);
	}
}

void Halite::setupRendering(unsigned short width, unsigned short height)
{
	//Delete buffers and vaos
	glDeleteBuffers(1, &vertex_buffer);
	glDeleteBuffers(1, &color_buffer);
	glDeleteBuffers(1, &strength_buffer);
	glDeleteVertexArrays(1, &vertex_attributes);
	//Generate buffers and vaos.
	glGenBuffers(1, &vertex_buffer);
	glGenBuffers(1, &color_buffer);
	glGenBuffers(1, &strength_buffer);
	glGenVertexArrays(1, &vertex_attributes);

	//Generate vertices of centers of squares:
	std::vector<float> vertexLocations(unsigned int(width) * height * 2); //2 because there are x and y values for every vertex.
	float xLoc = -1.0 + 1.0 / width, yLoc = 1.0 - 1.0 / height, dX = 2.0 / width, dY = 2.0 / height;
	for(unsigned int a = 0; a < vertexLocations.size(); a += 2)
	{
		vertexLocations[a] = xLoc;
		vertexLocations[a + 1] = yLoc;

		xLoc += dX;
		if(xLoc > 1.0)
		{
			xLoc = -1.0 + 1.0 / width;
			yLoc -= dY;
		}
	}

	//Bind vertex attribute object.
	glBindVertexArray(vertex_attributes);

	//Setup vertex buffer
	glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
	glBufferData(GL_ARRAY_BUFFER, vertexLocations.size() * sizeof(float), vertexLocations.data(), GL_STATIC_DRAW);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, NULL);


	//Create vector of floats (0.0) to reserve the memory for the color buffer and allow us to set the mode to GL_DYNAMIC_DRAW.
	std::vector<float> colors(unsigned int(width) * height * 3, 0.0); //r, g, and b components.
	
	//Setup color buffer
	glBindBuffer(GL_ARRAY_BUFFER, color_buffer);
	glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(float), colors.data(), GL_DYNAMIC_DRAW);
	glEnableVertexAttribArray(1);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, NULL);
	
	//Create vector of unsigned ints (0) to reserve the memory for the strength buffer and allow us to set the mode to GL_DYNAMIC_DRAW.
	std::vector<unsigned int> strengths(unsigned int(width) * height, 0); //r, g, and b components.
	
	//Setup strength buffer
	glBindBuffer(GL_ARRAY_BUFFER, strength_buffer);
	glBufferData(GL_ARRAY_BUFFER, strengths.size() * sizeof(GL_UNSIGNED_INT), strengths.data(), GL_DYNAMIC_DRAW);
	glEnableVertexAttribArray(2);
	glVertexAttribPointer(2, 1, GL_UNSIGNED_INT, GL_FALSE, 0, NULL);

	//Setup shaders:
	vertex_shader = glCreateShader(GL_VERTEX_SHADER);
	shaderFromFile(vertex_shader, "Classes/shaders/vertexshader.glsl", "vertex_shader");
	geometry_shader = glCreateShader(GL_GEOMETRY_SHADER);
	shaderFromFile(geometry_shader, "Classes/shaders/geometryshader.glsl", "geometry_shader");
	fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
	shaderFromFile(fragment_shader, "Classes/shaders/fragmentshader.glsl", "fragment_shader");

	//Setup shader program:
	shader_program = glCreateProgram();
	glAttachShader(shader_program, vertex_shader);
	glAttachShader(shader_program, geometry_shader);
	glAttachShader(shader_program, fragment_shader);
	glLinkProgram(shader_program);
	glDetachShader(shader_program, vertex_shader);
	glDetachShader(shader_program, geometry_shader);
	glDetachShader(shader_program, fragment_shader);

	//Set uniform:
	glUseProgram(shader_program);
	const float SPACE_FACTOR = 0.6;
	GLint widthLoc = glGetUniformLocation(shader_program, "width"), heightLoc = glGetUniformLocation(shader_program, "height");
	glUniform1f(widthLoc, dX * SPACE_FACTOR * 0.5);
	glUniform1f(heightLoc, dY * SPACE_FACTOR * 0.5);
	
	//Cleanup - delete shaders
	glDeleteShader(vertex_shader);
	glDeleteShader(geometry_shader);
	glDeleteShader(fragment_shader);
}

Halite::~Halite()
{
	glDeleteShader(vertex_shader);
	glDeleteShader(geometry_shader);
	glDeleteShader(fragment_shader);
	glDeleteProgram(shader_program);
	glDeleteBuffers(1, &vertex_buffer);
	glDeleteBuffers(1, &color_buffer);
	glDeleteBuffers(1, &strength_buffer);
	glDeleteVertexArrays(1, &vertex_attributes);
}

vertexshader.glsl ------

#version 400

layout(location = 0) in vec2 vp;
layout(location = 1) in vec3 vertexColor;
layout(location = 2) in uint vertexStrength;

out vec3 color;
out uint strength;

void main ()
{
	gl_Position = vec4 (vp, 0.0, 1.0);
	color = vertexColor;
	strength = vertexStrength;
}

geometryshader.glsl ----

#version 400

uniform float width;
uniform float height;

layout(points) in;
layout(triangles, max_vertices = 12) out;

in vec3 color[];
in uint strength[];
out vec3 fragColor;

void main()
{
	uint s = strength[0];
	vec4 position = gl_in[0].gl_Position;

	//Find top left vertex.
	vec4 tlPosition = position + vec4(-width, -height, 0.0, 0.0);

	//Find bottom left vertex.
	vec4 blPosition = position + vec4(-width, height, 0.0, 0.0);

	//Find top right vertex.
	vec4 trPosition = position + vec4(width, -height, 0.0, 0.0);

	//Find bottom right vertex.
	vec4 brPosition = position + vec4(width, height, 0.0, 0.0);

	//Generate top triangle
	fragColor = color[0] * (uint(s / 64) / 4.0);
	gl_Position = tlPosition;
	EmitVertex();
	gl_Position = position;
	EmitVertex();
	gl_Position = trPosition;
	EmitVertex();
	EndPrimitive();
	
	//Range is now 0 to 64:
	s %= 64;
	
	//Generate right triangle
	fragColor = color[0] * (uint(s / 16) / 4.0);
	//Position can remain the same.
	EmitVertex();
	gl_Position = position;
	EmitVertex();
	gl_Position = brPosition;
	EmitVertex();
	EndPrimitive();
	
	//Range is now 0 to 16:
	s %= 16;
	
	//Generate bottom triangle
	fragColor = color[0] * (uint(s / 4) / 4.0);
	//Position can remain the same.
	EmitVertex();
	gl_Position = position;
	EmitVertex();
	gl_Position = blPosition;
	EmitVertex();
	EndPrimitive();
	
	//Range is now 0 to 4:
	s %= 16;
	
	//Generate left triangle
	fragColor = color[0] * (s / 4.0);
	//Position can remain the same.
	EmitVertex();
	gl_Position = position;
	EmitVertex();
	gl_Position = tlPosition;
	EmitVertex();
	EndPrimitive();
}

OLD VERSION:
Halite.h   -------------

GLuint vertex_buffer, color_buffer, vertex_attributes, vertex_shader, geometry_shader, fragment_shader, shader_program;

Halite.cpp -------------

void Halite::render(short& turnNumber)
{
    confirmWithinGame(turnNumber);

	if(!full_game.empty())
	{
		hlt::Map * m = full_game[turnNumber];

		std::vector<float> colors(unsigned int(m->map_width) * m->map_height * 3);

		unsigned int colorLocation = 0;
		for(auto a = m->contents.begin(); a != m->contents.end(); a++)
		{
			for(auto b = a->begin(); b != a->end(); b++)
			{
				hlt::Color c = color_codes[b->owner];
				//const double BASE_DIMMING_FACTOR = 0.5;
				if(b->strength != 255)
				{
					const double TRUE_DIMMING_FACTOR = 0.11 + 0.9*pow(b->strength / 255.0, 0.8);
					c.r *= TRUE_DIMMING_FACTOR;
					c.g *= TRUE_DIMMING_FACTOR;
					c.b *= TRUE_DIMMING_FACTOR;
				}
				colors[colorLocation] = c.r;
				colors[colorLocation + 1] = c.g;
				colors[colorLocation + 2] = c.b;
				colorLocation += 3;
			}
		}

		glBindBuffer(GL_ARRAY_BUFFER, color_buffer);
		glBufferSubData(GL_ARRAY_BUFFER, 0, colors.size() * sizeof(float), colors.data());

		glUseProgram(shader_program);
		glBindVertexArray(vertex_attributes);
		glDrawArrays(GL_POINTS, 0, unsigned int(m->map_width) * m->map_height);
	}
}

void Halite::setupRendering(unsigned short width, unsigned short height)
{
	//Delete buffers and vaos
	glDeleteBuffers(1, &vertex_buffer);
	glDeleteBuffers(1, &color_buffer);
	glDeleteVertexArrays(1, &vertex_attributes);
	//Generate buffers and vaos.
	glGenBuffers(1, &vertex_buffer);
	glGenBuffers(1, &color_buffer);
	glGenVertexArrays(1, &vertex_attributes);

	//Generate vertices of centers of squares:
	std::vector<float> vertexLocations(unsigned int(width) * height * 2); //2 because there are x and y values for every vertex.
	float xLoc = -1.0 + 1.0 / width, yLoc = 1.0 - 1.0 / height, dX = 2.0 / width, dY = 2.0 / height;
	for(unsigned int a = 0; a < vertexLocations.size(); a += 2)
	{
		vertexLocations[a] = xLoc;
		vertexLocations[a + 1] = yLoc;

		xLoc += dX;
		if(xLoc > 1.0)
		{
			xLoc = -1.0 + 1.0 / width;
			yLoc -= dY;
		}
	}

	//Bind vertex attribute object.
	glBindVertexArray(vertex_attributes);

	//Setup vertex buffer
	glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
	glBufferData(GL_ARRAY_BUFFER, vertexLocations.size() * sizeof(float), vertexLocations.data(), GL_STATIC_DRAW);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, NULL);

	//Create vector of floats (0.0) to reserve the memory for the color buffer and allow us to set the mode to GL_DYNAMIC_DRAW.
	std::vector<float> colors(unsigned int(width) * height * 3); //r, g, and b components.

	//Setup color buffer
	glBindBuffer(GL_ARRAY_BUFFER, color_buffer);
	glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(float), colors.data(), GL_DYNAMIC_DRAW);
	glEnableVertexAttribArray(1);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, NULL);

	//Setup shaders:
	vertex_shader = glCreateShader(GL_VERTEX_SHADER);
	shaderFromFile(vertex_shader, "Classes/shaders/vertexshader.glsl", "vertex_shader");
	geometry_shader = glCreateShader(GL_GEOMETRY_SHADER);
	shaderFromFile(geometry_shader, "Classes/shaders/geometryshader.glsl", "geometry_shader");
	fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
	shaderFromFile(fragment_shader, "Classes/shaders/fragmentshader.glsl", "fragment_shader");

	//Setup shader program:
	shader_program = glCreateProgram();
	glAttachShader(shader_program, vertex_shader);
	glAttachShader(shader_program, geometry_shader);
	glAttachShader(shader_program, fragment_shader);
	glLinkProgram(shader_program);
	glDetachShader(shader_program, vertex_shader);
	glDetachShader(shader_program, geometry_shader);
	glDetachShader(shader_program, fragment_shader);

	//Set uniform:
	glUseProgram(shader_program);
	const float SPACE_FACTOR = 0.6;
	GLint widthLoc = glGetUniformLocation(shader_program, "width"), heightLoc = glGetUniformLocation(shader_program, "height");
	glUniform1f(widthLoc, dX * SPACE_FACTOR * 0.5);
	glUniform1f(heightLoc, dY * SPACE_FACTOR * 0.5);
	
	//Cleanup - delete shaders
	glDeleteShader(vertex_shader);
	glDeleteShader(geometry_shader);
	glDeleteShader(fragment_shader);
}

Halite::~Halite()
{
	glDeleteShader(vertex_shader);
	glDeleteShader(geometry_shader);
	glDeleteShader(fragment_shader);
	glDeleteProgram(shader_program);
	glDeleteBuffers(1, &vertex_buffer);
	glDeleteBuffers(1, &color_buffer);
	glDeleteVertexArrays(1, &vertex_attributes);
}

vertexshader.glsl ------

#version 400

layout(location = 0) in vec2 vp;
layout(location = 1) in vec3 vertexColor;

out vec3 color;

void main ()
{
	gl_Position = vec4 (vp, 0.0, 1.0);
	color = vertexColor;
}

geometryshader.glsl ----

#version 400

uniform float width;
uniform float height;

layout(points) in;
layout(triangle_strip, max_vertices = 4) out;

in vec3 color[];
out vec3 fragColor;

void main()
{
	fragColor = color[0];
	vec4 position = gl_in[0].gl_Position;

	//Add top left vertex.
	gl_Position = position + vec4(-width, -height, 0.0, 0.0);
	EmitVertex();

	//Add bottom left vertex.
	gl_Position = position + vec4(-width, height, 0.0, 0.0);
	EmitVertex();

	//Add top right vertex.
	gl_Position = position + vec4(width, -height, 0.0, 0.0);
	EmitVertex();

	//Add bottom right vertex.
	gl_Position = position + vec4(width, height, 0.0, 0.0);
	EmitVertex();

	//Finsih primitive.
	EndPrimitive();
}